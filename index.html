<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shape RNG with Glow</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #shapeName {
      margin: 20px 0 10px 0;
      font-size: 40px;
      color: red;
      font-weight: bold;
      user-select: none;
      z-index: 10;
    }
    #counter {
      position: absolute;
      top: 10px; left: 10px; right: 10px;
      font-size: 16px;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.3;
      white-space: pre-wrap;
      font-family: monospace;
      z-index: 2;
      color: white;
      user-select: none;
    }
    #rollBtn {
      margin: 15px 0 30px 0;
      padding: 15px 30px;
      background: white;
      border: none;
      border-radius: 10px;
      font-size: 20px;
      cursor: pointer;
      z-index: 2;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: black;
      user-select: none;
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="counter"></div>
  <div id="shapeName"></div>
  <button id="rollBtn">ROLL</button>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    const shapes = [
      {name:"Triangle", sides:3, weight: 1/2},
      {name:"Square", sides:4, weight: 1/4},
      {name:"Rectangle", sides:4, weight: 1/8, rectangle:true},
      {name:"Circle", sides:0, weight: 1/16},
      {name:"Semi Circle", sides:0, weight: 1/32, semi:true},
      {name:"Pentagon", sides:5, weight: 1/64},
      {name:"Hexagon", sides:6, weight: 1/128},
      {name:"Heptagon", sides:7, weight: 1/256},
      {name:"Octagon", sides:8, weight: 1/512},
      {name:"Nonagon", sides:9, weight: 1/1024},
      {name:"Decagon", sides:10, weight: 1/2048},
    ];

    const chances = shapes.map(s => 1/s.weight);
    const totalChance = chances.reduce((a,b) => a + b, 0);
    const probabilities = chances.map(c => c/totalChance);

    function weightedRandom(items, probs) {
      let r = Math.random();
      let acc = 0;
      for (let i=0; i<items.length; i++) {
        acc += probs[i];
        if (r <= acc) return items[i];
      }
      return items[items.length-1];
    }

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(
      window.innerWidth / -150, window.innerWidth / 150,
      window.innerHeight / 150, window.innerHeight / -150,
      0.1, 1000
    );
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Materials for glow (white semi-transparent) and main shape (white)
    const glowMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity: 0.3});
    const fillMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    const lineMaterial = new THREE.LineBasicMaterial({color: 0x888888});

    let currentShapeMesh = null;
    let currentGlowMesh = null;

    function clearCurrentShape() {
      if(currentShapeMesh) {
        scene.remove(currentShapeMesh);
        currentShapeMesh.geometry.dispose();
        currentShapeMesh.material.dispose();
        currentShapeMesh = null;
      }
      if(currentGlowMesh) {
        scene.remove(currentGlowMesh);
        currentGlowMesh.geometry.dispose();
        currentGlowMesh.material.dispose();
        currentGlowMesh = null;
      }
    }

    function addShapeToScene(shape, scale=1) {
      // Glow mesh (slightly bigger)
      const glowGeometry = new THREE.ShapeGeometry(shape);
      glowGeometry.scale(scale * 1.15, scale * 1.15, 1);
      const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      scene.add(glowMesh);
      currentGlowMesh = glowMesh;

      // Main shape mesh
      const geometry = new THREE.ShapeGeometry(shape);
      geometry.scale(scale, scale, 1);
      const mesh = new THREE.Mesh(geometry, fillMaterial);

      // Outline
      const edges = new THREE.EdgesGeometry(geometry);
      const outline = new THREE.LineSegments(edges, lineMaterial);
      mesh.add(outline);

      scene.add(mesh);
      currentShapeMesh = mesh;
    }

    function createPolygonShape(sides, radius = 2) {
      const shape = new THREE.Shape();
      if (sides < 3) return shape; // invalid polygon
      
      const angleStep = (Math.PI * 2) / sides;
      shape.moveTo(radius, 0);
      for(let i = 1; i < sides; i++) {
        const x = radius * Math.cos(i * angleStep);
        const y = radius * Math.sin(i * angleStep);
        shape.lineTo(x, y);
      }
      shape.closePath();
      return shape;
    }

    function createCircleShape(radius=2) {
      const shape = new THREE.Shape();
      shape.absarc(0, 0, radius, 0, Math.PI * 2, false);
      return shape;
    }

    function createSemiCircleShape(radius=2) {
      const shape = new THREE.Shape();
      shape.moveTo(-radius, 0);
      shape.absarc(0, 0, radius, Math.PI, 0, false);
      shape.lineTo(radius, 0);
      shape.closePath();
      return shape;
    }

    function createRectangleShape(width=3, height=2) {
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, -height/2);
      shape.lineTo(width/2, -height/2);
      shape.lineTo(width/2, height/2);
      shape.lineTo(-width/2, height/2);
      shape.closePath();
      return shape;
    }

    const shapeNameDiv = document.getElementById('shapeName');
    const counterDiv = document.getElementById('counter');

    let shapeCounts = JSON.parse(localStorage.getItem('shapeCounts')) || {};
    for (const s of shapes) {
      if (!(s.name in shapeCounts)) shapeCounts[s.name] = 0;
    }

    function updateCounter() {
      let lines = [];
      for (const s of shapes) {
        lines.push(`${s.name.padEnd(12)}: ${shapeCounts[s.name]}`);
      }
      counterDiv.textContent = lines.join('\n');
    }
    updateCounter();

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.left = window.innerWidth / -150;
      camera.right = window.innerWidth / 150;
      camera.top = window.innerHeight / 150;
      camera.bottom = window.innerHeight / -150;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const rollBtn = document.getElementById('rollBtn');
    rollBtn.onclick = () => {
      const rolledShape = weightedRandom(shapes, probabilities);

      let shape;
      if (rolledShape.semi) {
        shape = createSemiCircleShape(2);
      } else if (rolledShape.name === "Circle") {
        shape = createCircleShape(2);
      } else if (rolledShape.rectangle) {
        shape = createRectangleShape(3, 2);
      } else {
        shape = createPolygonShape(rolledShape.sides, 2);
      }

      clearCurrentShape();
      addShapeToScene(shape);

      shapeNameDiv.textContent = rolledShape.name;

      shapeCounts[rolledShape.name]++;
      localStorage.setItem('shapeCounts', JSON.stringify(shapeCounts));
      localStorage.setItem('lastShape', rolledShape.name);
      updateCounter();
    };

    // On load show last shape if any
    const lastShapeName = localStorage.getItem('lastShape');
    if (lastShapeName && shapeCounts[lastShapeName] > 0) {
      const lastShapeObj = shapes.find(s => s.name === lastShapeName);
      if (lastShapeObj) {
        let shape;
        if (lastShapeObj.semi) {
          shape = createSemiCircleShape(2);
        } else if (lastShapeObj.name === "Circle") {
          shape = createCircleShape(2);
        } else if (lastShapeObj.rectangle) {
          shape = createRectangleShape(3, 2);
        } else {
          shape = createPolygonShape(lastShapeObj.sides, 2);
        }
        addShapeToScene(shape);
        shapeNameDiv.textContent = lastShapeName;
      }
    }
  </script>
</body>
</html>
