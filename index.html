<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Shape RNG - Parts Flying In</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%; width: 100%;
    background: black;
    overflow: hidden;
    font-family: sans-serif;
    color: white;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #shapeName {
    margin: 20px 0 10px 0;
    font-size: 40px;
    color: red;
    font-weight: bold;
    user-select: none;
    z-index: 10;
    min-height: 48px;
    text-align: center;
    width: 100%;
  }
  #counter {
    position: absolute;
    top: 10px; left: 10px; right: 10px;
    font-size: 16px;
    max-height: 120px;
    overflow-y: auto;
    line-height: 1.3;
    white-space: pre-wrap;
    font-family: monospace;
    z-index: 2;
    color: white;
    user-select: none;
  }
  #rollBtn {
    margin: 15px 0 30px 0;
    padding: 15px 30px;
    background: white;
    border: none;
    border-radius: 10px;
    font-size: 20px;
    cursor: pointer;
    z-index: 2;
    user-select: none;
  }
  #rollBtn:disabled {
    background: #aaa;
    cursor: not-allowed;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: black;
    user-select: none;
    position: relative;
    z-index: 1;
  }
</style>
</head>
<body>
<div id="counter"></div>
<div id="shapeName"></div>
<button id="rollBtn">ROLL</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
  // Shape definitions
  const shapes = [
    {name:"Triangle", sides:3, chance: 1/2},
    {name:"Square", sides:4, chance: 1/4},
    {name:"Rectangle", sides:4, chance: 1/8, rectangle:true},
    {name:"Circle", sides:0, chance: 1/16},
    {name:"Semi Circle", sides:0, chance: 1/32, semi:true},
    {name:"Pentagon", sides:5, chance: 1/64},
    {name:"Hexagon", sides:6, chance: 1/128},
    {name:"Heptagon", sides:7, chance: 1/256},
    {name:"Octagon", sides:8, chance: 1/512},
    {name:"Nonagon", sides:9, chance: 1/1024},
    {name:"Decagon", sides:10, chance: 1/2048},
  ];

  const totalChance = shapes.reduce((sum, s) => sum + s.chance, 0);
  const probabilities = shapes.map(s => s.chance / totalChance);

  function weightedRandom(items, probs) {
    let r = Math.random();
    let acc = 0;
    for (let i=0; i<items.length; i++) {
      acc += probs[i];
      if (r <= acc) return items[i];
    }
    return items[items.length-1];
  }

  // THREE.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(
    window.innerWidth / -150, window.innerWidth / 150,
    window.innerHeight / 150, window.innerHeight / -150,
    0.1, 1000
  );
  camera.position.z = 10;

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Materials
  const glowMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity: 0.3});
  const fillMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
  const lineMaterial = new THREE.LineBasicMaterial({color: 0x888888});

  // Geometry creators
  function createPolygonShapePoints(sides, radius=2) {
    const points = [];
    if(sides < 3) return points;
    const angleStep = (Math.PI*2) / sides;
    for(let i=0; i<sides; i++){
      points.push(new THREE.Vector2(radius * Math.cos(i*angleStep), radius * Math.sin(i*angleStep)));
    }
    return points;
  }

  function createCircleShapePoints(radius=2, segments=64){
    const points = [];
    for(let i=0; i<=segments; i++){
      const angle = (i/segments) * Math.PI*2;
      points.push(new THREE.Vector2(radius * Math.cos(angle), radius * Math.sin(angle)));
    }
    return points;
  }

  function createSemiCircleShapePoints(radius=2, segments=32){
    const points = [new THREE.Vector2(-radius, 0)];
    for(let i=0; i<=segments; i++){
      const angle = Math.PI - (i/segments)*Math.PI;
      points.push(new THREE.Vector2(radius * Math.cos(angle), radius * Math.sin(angle)));
    }
    points.push(new THREE.Vector2(radius, 0));
    return points;
  }

  function createRectangleShapePoints(width=3, height=2){
    return [
      new THREE.Vector2(-width/2, -height/2),
      new THREE.Vector2(width/2, -height/2),
      new THREE.Vector2(width/2, height/2),
      new THREE.Vector2(-width/2, height/2)
    ];
  }

  // Convert points to shape (closed path)
  function pointsToShape(points){
    const shape = new THREE.Shape();
    if(points.length === 0) return shape;
    shape.moveTo(points[0].x, points[0].y);
    for(let i=1; i<points.length; i++){
      shape.lineTo(points[i].x, points[i].y);
    }
    shape.closePath();
    return shape;
  }

  // For splitting points array into N groups
  function splitPoints(points, partsCount){
    const result = [];
    const len = points.length;
    for(let i=0; i<partsCount; i++){
      const start = Math.floor(i * len / partsCount);
      const end = Math.floor((i+1) * len / partsCount);
      const partPoints = points.slice(start, end);
      // To connect the last point back to the first of this part for a closed shape,
      // also include the connecting line between last and first in this segment
      // For simplicity, just add first point to end
      if(partPoints.length > 0) partPoints.push(partPoints[0]);
      result.push(partPoints);
    }
    return result;
  }

  // Prebuild shapes points for parts
  const prebuiltShapeParts = {};
  for (const shapeObj of shapes) {
    let pts;
    if(shapeObj.semi){
      pts = createSemiCircleShapePoints(2);
    } else if(shapeObj.name === "Circle"){
      pts = createCircleShapePoints(2);
    } else if(shapeObj.rectangle){
      pts = createRectangleShapePoints(3,2);
    } else {
      pts = createPolygonShapePoints(shapeObj.sides, 2);
    }
    // split points into 3 parts
    prebuiltShapeParts[shapeObj.name] = splitPoints(pts, 3);
  }

  // Part meshes
  const partMeshes = [];
  const partOutlineMeshes = [];

  // Glow mesh - full shape glow behind parts
  let glowMesh = null;

  function clearParts(){
    partMeshes.forEach(m => scene.remove(m));
    partOutlineMeshes.forEach(m => scene.remove(m));
    partMeshes.length = 0;
    partOutlineMeshes.length = 0;
    if(glowMesh){
      scene.remove(glowMesh);
      glowMesh.geometry.dispose();
      glowMesh = null;
    }
  }

  // Create mesh for a part (with fill and outline)
  function createPartMesh(partPoints){
    const shape = pointsToShape(partPoints);
    const geom = new THREE.ShapeGeometry(shape);

    const mesh = new THREE.Mesh(geom, fillMaterial.clone());
    const edges = new THREE.EdgesGeometry(geom);
    const outline = new THREE.LineSegments(edges, lineMaterial.clone());
    mesh.add(outline);
    return {mesh, outline};
  }

  // Animate from start position to end position with rotation easing
  function animatePart(part, fromPos, fromRot, toPos, toRot, duration, onComplete){
    const startTime = performance.now();
    function step(time){
      const elapsed = time - startTime;
      const t = Math.min(elapsed / duration, 1);
      // simple easeOutCubic
      const easeT = 1 - Math.pow(1 - t, 3);

      part.mesh.position.lerpVectors(fromPos, toPos, easeT);
      part.mesh.rotation.z = fromRot + (toRot - fromRot) * easeT;

      if(t < 1){
        requestAnimationFrame(step);
      } else {
        if(onComplete) onComplete();
      }
    }
    requestAnimationFrame(step);
  }

  // Set part initial offscreen positions (different edges)
  function getOffscreenPos(index){
    const margin = 8;
    switch(index){
      case 0: return new THREE.Vector3(-window.innerWidth/150 - margin, 0, 0); // Left edge
      case 1: return new THREE.Vector3(window.innerWidth/150 + margin, 0, 0);  // Right edge
      case 2: return new THREE.Vector3(0, window.innerHeight/150 + margin, 0); // Top edge
      default: return new THREE.Vector3(0, 0, 0);
    }
  }

  // Compose full shape glow mesh
  function createGlowMesh(shapeName){
    if(glowMesh){
      scene.remove(glowMesh);
      glowMesh.geometry.dispose();
      glowMesh.material.dispose();
      glowMesh = null;
    }
    const points = [];
    // get all points combined
    const parts = prebuiltShapeParts[shapeName];
    for(const p of parts){
      for(const pt of p) points.push(pt);
    }
    const shape = pointsToShape(points);
    const geom = new THREE.ShapeGeometry(shape);
    geom.scale(1.15,1.15,1);

    glowMesh = new THREE.Mesh(geom, glowMaterial);
    scene.add(glowMesh);
  }

  // UI elements
  const shapeNameDiv = document.getElementById('shapeName');
  const counterDiv = document.getElementById('counter');
  const rollBtn = document.getElementById('rollBtn');

  let shapeCounts = JSON.parse(localStorage.getItem('shapeCounts')) || {};
  for (const s of shapes) {
    if (!(s.name in shapeCounts)) shapeCounts[s.name] = 0;
  }

  function updateCounter() {
    let lines = [];
    for (const s of shapes) {
      lines.push(`${s.name.padEnd(12)}: ${shapeCounts[s.name]}`);
    }
    counterDiv.textContent = lines.join('\n');
  }
  updateCounter();

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.left = window.innerWidth / -150;
    camera.right = window.innerWidth / 150;
    camera.top = window.innerHeight / 150;
    camera.bottom = window.innerHeight / -150;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // On roll button click - pick shape and animate parts
  rollBtn.onclick = () => {
    if(partMeshes.length > 0) return; // prevent rolling while animating
    rollBtn.disabled = true;

    const finalShape = weightedRandom(shapes, probabilities);

    clearParts();
    createGlowMesh(finalShape.name);
    shapeNameDiv.textContent = finalShape.name;

    const partsPoints = prebuiltShapeParts[finalShape.name];

    // Create part meshes & place offscreen
    for(let i=0; i<3; i++){
      const {mesh, outline} = createPartMesh(partsPoints[i]);
      mesh.position.copy(getOffscreenPos(i));
      mesh.rotation.z = (Math.random() - 0.5) * Math.PI/2; // random start rotation
      scene.add(mesh);
      partMeshes.push(mesh);
      partOutlineMeshes.push(outline);
    }

    // Animate parts to center (0,0) and 0 rotation, staggered
    let finishedCount = 0;
    for(let i=0; i<3; i++){
      animatePart(
        {mesh: partMeshes[i]},
        partMeshes[i].position.clone(),
        partMeshes[i].rotation.z,
        new THREE.Vector3(0,0,0),
        0,
        1000,
        () => {
          finishedCount++;
          if(finishedCount === 3){
            // All parts arrived
            shapeCounts[finalShape.name]++;
            localStorage.setItem('shapeCounts', JSON.stringify(shapeCounts));
            localStorage.setItem('lastShape', finalShape.name);
            updateCounter();
            rollBtn.disabled = false;
          }
        }
      );
    }
  };

  // Show last shape on load (assembled instantly)
  function showLastShape(){
    const lastShapeName = localStorage.getItem('lastShape');
    if(lastShapeName && shapeCounts[lastShapeName] > 0){
      clearParts();
      createGlowMesh(lastShapeName);
      shapeNameDiv.textContent = lastShapeName;
      const partsPoints = prebuiltShapeParts[lastShapeName];
      for(let i=0; i<3; i++){
        const {mesh, outline} = createPartMesh(partsPoints[i]);
        mesh.position.set(0,0,0);
        mesh.rotation.z = 0;
        scene.add(mesh);
        partMeshes.push(mesh);
        partOutlineMeshes.push(outline);
      }
    }
  }
  showLastShape();

</script>
</body>
</html>
