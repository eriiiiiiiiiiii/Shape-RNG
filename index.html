<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shape RNG with Glow and Rolling Animation</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #shapeName {
      margin: 20px 0 10px 0;
      font-size: 40px;
      color: red;
      font-weight: bold;
      user-select: none;
      z-index: 10;
      min-height: 48px;
      text-align: center;
      width: 100%;
    }
    #counter {
      position: absolute;
      top: 10px; left: 10px; right: 10px;
      font-size: 16px;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.3;
      white-space: pre-wrap;
      font-family: monospace;
      z-index: 2;
      color: white;
      user-select: none;
    }
    #rollBtn {
      margin: 15px 0 30px 0;
      padding: 15px 30px;
      background: white;
      border: none;
      border-radius: 10px;
      font-size: 20px;
      cursor: pointer;
      z-index: 2;
      user-select: none;
      user-select: none;
    }
    #rollBtn:disabled {
      background: #aaa;
      cursor: not-allowed;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: black;
      user-select: none;
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="counter"></div>
  <div id="shapeName"></div>
  <button id="rollBtn">ROLL</button>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // Shapes and chances as before
    const shapes = [
      {name:"Triangle", sides:3, chance: 1/2},
      {name:"Square", sides:4, chance: 1/4},
      {name:"Rectangle", sides:4, chance: 1/8, rectangle:true},
      {name:"Circle", sides:0, chance: 1/16},
      {name:"Semi Circle", sides:0, chance: 1/32, semi:true},
      {name:"Pentagon", sides:5, chance: 1/64},
      {name:"Hexagon", sides:6, chance: 1/128},
      {name:"Heptagon", sides:7, chance: 1/256},
      {name:"Octagon", sides:8, chance: 1/512},
      {name:"Nonagon", sides:9, chance: 1/1024},
      {name:"Decagon", sides:10, chance: 1/2048},
    ];

    // Total chance sum & normalize probabilities
    const totalChance = shapes.reduce((sum, s) => sum + s.chance, 0);
    const probabilities = shapes.map(s => s.chance / totalChance);

    function weightedRandom(items, probs) {
      let r = Math.random();
      let acc = 0;
      for (let i=0; i<items.length; i++) {
        acc += probs[i];
        if (r <= acc) return items[i];
      }
      return items[items.length-1];
    }

    // THREE.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(
      window.innerWidth / -150, window.innerWidth / 150,
      window.innerHeight / 150, window.innerHeight / -150,
      0.1, 1000
    );
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Materials for glow and main shape
    const glowMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity: 0.3});
    const fillMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    const lineMaterial = new THREE.LineBasicMaterial({color: 0x888888});

    let currentShapeMesh = null;
    let currentGlowMesh = null;

    function clearCurrentShape() {
      if(currentShapeMesh) {
        scene.remove(currentShapeMesh);
        currentShapeMesh.geometry.dispose();
        currentShapeMesh.material.dispose();
        currentShapeMesh = null;
      }
      if(currentGlowMesh) {
        scene.remove(currentGlowMesh);
        currentGlowMesh.geometry.dispose();
        currentGlowMesh.material.dispose();
        currentGlowMesh = null;
      }
    }

    function addShapeToScene(shape, scale=1) {
      // Glow mesh (slightly bigger)
      const glowGeometry = new THREE.ShapeGeometry(shape);
      glowGeometry.scale(scale * 1.15, scale * 1.15, 1);
      const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      scene.add(glowMesh);
      currentGlowMesh = glowMesh;

      // Main shape mesh
      const geometry = new THREE.ShapeGeometry(shape);
      geometry.scale(scale, scale, 1);
      const mesh = new THREE.Mesh(geometry, fillMaterial);

      // Outline
      const edges = new THREE.EdgesGeometry(geometry);
      const outline = new THREE.LineSegments(edges, lineMaterial);
      mesh.add(outline);

      scene.add(mesh);
      currentShapeMesh = mesh;
    }

    function createPolygonShape(sides, radius = 2) {
      const shape = new THREE.Shape();
      if (sides < 3) return shape;
      const angleStep = (Math.PI * 2) / sides;
      shape.moveTo(radius, 0);
      for(let i = 1; i < sides; i++) {
        const x = radius * Math.cos(i * angleStep);
        const y = radius * Math.sin(i * angleStep);
        shape.lineTo(x, y);
      }
      shape.closePath();
      return shape;
    }

    function createCircleShape(radius=2) {
      const shape = new THREE.Shape();
      shape.absarc(0, 0, radius, 0, Math.PI * 2, false);
      return shape;
    }

    function createSemiCircleShape(radius=2) {
      const shape = new THREE.Shape();
      shape.moveTo(-radius, 0);
      shape.absarc(0, 0, radius, Math.PI, 0, false);
      shape.lineTo(radius, 0);
      shape.closePath();
      return shape;
    }

    function createRectangleShape(width=3, height=2) {
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, -height/2);
      shape.lineTo(width/2, -height/2);
      shape.lineTo(width/2, height/2);
      shape.lineTo(-width/2, height/2);
      shape.closePath();
      return shape;
    }

    const shapeNameDiv = document.getElementById('shapeName');
    const counterDiv = document.getElementById('counter');
    const rollBtn = document.getElementById('rollBtn');

    let shapeCounts = JSON.parse(localStorage.getItem('shapeCounts')) || {};
    for (const s of shapes) {
      if (!(s.name in shapeCounts)) shapeCounts[s.name] = 0;
    }

    function updateCounter() {
      let lines = [];
      for (const s of shapes) {
        lines.push(`${s.name.padEnd(12)}: ${shapeCounts[s.name]}`);
      }
      counterDiv.textContent = lines.join('\n');
    }
    updateCounter();

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.left = window.innerWidth / -150;
      camera.right = window.innerWidth / 150;
      camera.top = window.innerHeight / 150;
      camera.bottom = window.innerHeight / -150;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Helper: get shape mesh from shape object
    function getShapeGeometry(shapeObj) {
      if (shapeObj.semi) return createSemiCircleShape(2);
      if (shapeObj.name === "Circle") return createCircleShape(2);
      if (shapeObj.rectangle) return createRectangleShape(3, 2);
      return createPolygonShape(shapeObj.sides, 2);
    }

    // Animation parameters
    let rolling = false;

    rollBtn.onclick = () => {
      if (rolling) return; // Prevent multiple clicks
      rolling = true;
      rollBtn.disabled = true;

      // Final chosen shape
      const finalShape = weightedRandom(shapes, probabilities);

      // Animation control variables
      let elapsed = 0;
      const totalDuration = 4000; // 4 seconds total animation
      const minInterval = 50;     // fastest interval ms
      const maxInterval = 400;    // slowest interval ms

      // Time control for slowing down
      let lastTime = performance.now();
      let nextUpdate = 0;
      let interval = minInterval;

      // Current displayed shape (starts null)
      let currentDisplayedShape = null;

      // Animation loop function
      function animationStep(time) {
        elapsed += (time - lastTime);
        lastTime = time;

        if (elapsed >= nextUpdate) {
          // Pick a random shape weighted for "rolling"
          // To keep variety, use uniform random from all shapes here (or weighted)
          currentDisplayedShape = weightedRandom(shapes, probabilities);

          // Show the shape
          clearCurrentShape();
          addShapeToScene(getShapeGeometry(currentDisplayedShape));
          shapeNameDiv.textContent = currentDisplayedShape.name;

          // Slow down interval exponentially (ease out)
          // Map elapsed 0 to totalDuration to interval maxInterval to minInterval
          const t = Math.min(elapsed / totalDuration, 1);
          interval = minInterval + (maxInterval - minInterval) * t*t; // quadratic easing

          nextUpdate = elapsed + interval;
        }

        if (elapsed < totalDuration) {
          requestAnimationFrame(animationStep);
        } else {
          // End animation: show final shape for real
          clearCurrentShape();
          addShapeToScene(getShapeGeometry(finalShape));
          shapeNameDiv.textContent = finalShape.name;

          // Update counts and localStorage
          shapeCounts[finalShape.name]++;
          localStorage.setItem('shapeCounts', JSON.stringify(shapeCounts));
          localStorage.setItem('lastShape', finalShape.name);
          updateCounter();

          rolling = false;
          rollBtn.disabled = false;
        }
      }

      // Start animation
      lastTime = performance.now();
      elapsed = 0;
      nextUpdate = 0;
      interval = minInterval;
      requestAnimationFrame(animationStep);
    };

    // On load show last shape if any
    const lastShapeName = localStorage.getItem('lastShape');
    if (lastShapeName && shapeCounts[lastShapeName] > 0) {
      const lastShapeObj = shapes.find(s => s.name === lastShapeName);
      if (lastShapeObj) {
        clearCurrentShape();
        addShapeToScene(getShapeGeometry(lastShapeObj));
        shapeNameDiv.textContent = lastShapeName;
      }
    }
  </script>
</body>
</html>
