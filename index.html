<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shape RNG with Fade-in and Faster Rolling</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #shapeName {
      margin: 20px 0 10px 0;
      font-size: 40px;
      color: red;
      font-weight: bold;
      user-select: none;
      z-index: 10;
      min-height: 48px;
      text-align: center;
      width: 100%;
    }
    #counter {
      position: absolute;
      top: 10px; left: 10px; right: 10px;
      font-size: 16px;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.3;
      white-space: pre-wrap;
      font-family: monospace;
      z-index: 2;
      color: white;
      user-select: none;
    }
    #rollBtn {
      margin: 15px 0 30px 0;
      padding: 15px 30px;
      background: white;
      border: none;
      border-radius: 10px;
      font-size: 20px;
      cursor: pointer;
      z-index: 2;
      user-select: none;
    }
    #rollBtn:disabled {
      background: #aaa;
      cursor: not-allowed;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: black;
      user-select: none;
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="counter"></div>
  <div id="shapeName"></div>
  <button id="rollBtn">ROLL</button>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    const shapes = [
      {name:"Triangle", sides:3, chance: 1/2},
      {name:"Square", sides:4, chance: 1/4},
      {name:"Rectangle", sides:4, chance: 1/8, rectangle:true},
      {name:"Circle", sides:0, chance: 1/16},
      {name:"Semi Circle", sides:0, chance: 1/32, semi:true},
      {name:"Pentagon", sides:5, chance: 1/64},
      {name:"Hexagon", sides:6, chance: 1/128},
      {name:"Heptagon", sides:7, chance: 1/256},
      {name:"Octagon", sides:8, chance: 1/512},
      {name:"Nonagon", sides:9, chance: 1/1024},
      {name:"Decagon", sides:10, chance: 1/2048},
    ];

    const totalChance = shapes.reduce((sum, s) => sum + s.chance, 0);
    const probabilities = shapes.map(s => s.chance / totalChance);

    function weightedRandom(items, probs) {
      let r = Math.random();
      let acc = 0;
      for (let i=0; i<items.length; i++) {
        acc += probs[i];
        if (r <= acc) return items[i];
      }
      return items[items.length-1];
    }

    // THREE.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(
      window.innerWidth / -150, window.innerWidth / 150,
      window.innerHeight / 150, window.innerHeight / -150,
      0.1, 1000
    );
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Materials with transparency enabled
    const glowMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity: 0.3});
    const fillMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity: 1});
    const lineMaterial = new THREE.LineBasicMaterial({color: 0x888888, transparent:true, opacity: 1});

    // Geometry creators
    function createPolygonShape(sides, radius = 2) {
      const shape = new THREE.Shape();
      if (sides < 3) return shape;
      const angleStep = (Math.PI * 2) / sides;
      shape.moveTo(radius, 0);
      for(let i = 1; i < sides; i++) {
        const x = radius * Math.cos(i * angleStep);
        const y = radius * Math.sin(i * angleStep);
        shape.lineTo(x, y);
      }
      shape.closePath();
      return shape;
    }

    function createCircleShape(radius=2) {
      const shape = new THREE.Shape();
      shape.absarc(0, 0, radius, 0, Math.PI * 2, false);
      return shape;
    }

    function createSemiCircleShape(radius=2) {
      const shape = new THREE.Shape();
      shape.moveTo(-radius, 0);
      shape.absarc(0, 0, radius, Math.PI, 0, false);
      shape.lineTo(radius, 0);
      shape.closePath();
      return shape;
    }

    function createRectangleShape(width=3, height=2) {
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, -height/2);
      shape.lineTo(width/2, -height/2);
      shape.lineTo(width/2, height/2);
      shape.lineTo(-width/2, height/2);
      shape.closePath();
      return shape;
    }

    // Prebuild shapes geometries
    const prebuiltShapes = {};
    for (const shapeObj of shapes) {
      let geom;
      if (shapeObj.semi) {
        geom = createSemiCircleShape(2);
      } else if (shapeObj.name === "Circle") {
        geom = createCircleShape(2);
      } else if (shapeObj.rectangle) {
        geom = createRectangleShape(3, 2);
      } else {
        geom = createPolygonShape(shapeObj.sides, 2);
      }
      prebuiltShapes[shapeObj.name] = geom;
    }

    // Single reusable meshes
    let shapeMesh = null;
    let glowMesh = null;

    function initMeshes() {
      if (!shapeMesh) {
        const geometry = new THREE.ShapeGeometry(new THREE.Shape());
        shapeMesh = new THREE.Mesh(geometry, fillMaterial);
        scene.add(shapeMesh);
      }
      if (!glowMesh) {
        const glowGeometry = new THREE.ShapeGeometry(new THREE.Shape());
        glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glowMesh);
      }
    }

    function setMeshOpacity(opacity) {
      fillMaterial.opacity = opacity;
      glowMaterial.opacity = opacity * 0.3;
      lineMaterial.opacity = opacity;
    }

    // Animate fade in for final shape over duration ms
    function fadeIn(duration = 600, onComplete) {
      let start = null;
      function step(timestamp) {
        if (!start) start = timestamp;
        const elapsed = timestamp - start;
        const progress = Math.min(elapsed / duration, 1);
        setMeshOpacity(progress);
        if (progress < 1) {
          requestAnimationFrame(step);
        } else {
          if (onComplete) onComplete();
        }
      }
      requestAnimationFrame(step);
    }

    function updateMeshes(shapeName) {
      const geom = prebuiltShapes[shapeName];
      if (!geom) return;

      // Update main shape geometry
      shapeMesh.geometry.dispose();
      shapeMesh.geometry = new THREE.ShapeGeometry(geom);
      shapeMesh.geometry.scale(1,1,1);

      // Update glow geometry with scale
      glowMesh.geometry.dispose();
      const glowGeom = new THREE.ShapeGeometry(geom);
      glowGeom.scale(1.15,1.15,1);
      glowMesh.geometry = glowGeom;

      // Outline
      if (!shapeMesh.outline) {
        const edges = new THREE.EdgesGeometry(shapeMesh.geometry);
        shapeMesh.outline = new THREE.LineSegments(edges, lineMaterial);
        shapeMesh.add(shapeMesh.outline);
      } else {
        shapeMesh.remove(shapeMesh.outline);
        const edges = new THREE.EdgesGeometry(shapeMesh.geometry);
        shapeMesh.outline = new THREE.LineSegments(edges, lineMaterial);
        shapeMesh.add(shapeMesh.outline);
      }
    }

    initMeshes();

    // UI elements
    const shapeNameDiv = document.getElementById('shapeName');
    const counterDiv = document.getElementById('counter');
    const rollBtn = document.getElementById('rollBtn');

    let shapeCounts = JSON.parse(localStorage.getItem('shapeCounts')) || {};
    for (const s of shapes) {
      if (!(s.name in shapeCounts)) shapeCounts[s.name] = 0;
    }

    function updateCounter() {
      let lines = [];
      for (const s of shapes) {
        lines.push(`${s.name.padEnd(12)}: ${shapeCounts[s.name]}`);
      }
      counterDiv.textContent = lines.join('\n');
    }
    updateCounter();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.left = window.innerWidth / -150;
      camera.right = window.innerWidth / 150;
      camera.top = window.innerHeight / 150;
      camera.bottom = window.innerHeight / -150;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Rolling animation
    let rolling = false;

    rollBtn.onclick = () => {
      if (rolling) return;
      rolling = true;
      rollBtn.disabled = true;

      const finalShape = weightedRandom(shapes, probabilities);

      let interval = 20;     // start interval ms (faster)
      const maxInterval = 400; // max interval ms
      let lastUpdate = performance.now();

      // Make sure opacity is full during rolling
      setMeshOpacity(1);

      function animationStep(time) {
        if (time - lastUpdate >= interval) {
          lastUpdate = time;

          // Pick random rolling shape
          const rollingShape = weightedRandom(shapes, probabilities);

          updateMeshes(rollingShape.name);
          shapeNameDiv.textContent = rollingShape.name;

          interval += 10;
          if (interval > maxInterval) interval = maxInterval;
        }

        if (interval < maxInterval) {
          requestAnimationFrame(animationStep);
        } else {
          // Final shape show with fade-in
          updateMeshes(finalShape.name);
          shapeNameDiv.textContent = finalShape.name;

          // Start fade in from 0 opacity
          setMeshOpacity(0);
          fadeIn(600, () => {
            shapeCounts[finalShape.name]++;
            localStorage.setItem('shapeCounts', JSON.stringify(shapeCounts));
            localStorage.setItem('lastShape', finalShape.name);
            updateCounter();

            rolling = false;
            rollBtn.disabled = false;
          });
        }
      }

      requestAnimationFrame(animationStep);
    };

    // Show last shape on load
    const lastShapeName = localStorage.getItem('lastShape');
    if (lastShapeName && shapeCounts[lastShapeName] > 0) {
      if (prebuiltShapes[lastShapeName]) {
        updateMeshes(lastShapeName);
        shapeNameDiv.textContent = lastShapeName;
      }
    }
  </script>
</body>
</html>
