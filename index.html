<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shape RNG</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      user-select: none;
    }
    canvas {
      display: block;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 0;
    }
    #rollBtn {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      background: white;
      border: none;
      border-radius: 10px;
      font-size: 20px;
      cursor: pointer;
      z-index: 2;
    }
    #counter {
      position: absolute;
      top: 10px; left: 10px; right: 10px;
      font-size: 16px;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.3;
      z-index: 2;
      white-space: pre-wrap;
      font-family: monospace;
      color: white;
    }
  </style>
</head>
<body>
  <div id="counter"></div>
  <button id="rollBtn">ROLL</button>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // Shapes and their weights (1/chance)
    const shapes = [
      {name:"Triangle", weight: 1/2},
      {name:"Square", weight: 1/4},
      {name:"Rectangle", weight: 1/8},
      {name:"Circle", weight: 1/16},
      {name:"Semi Circle", weight: 1/32},
      {name:"Pentagon", weight: 1/64},
      {name:"Hexagon", weight: 1/128},
      {name:"Heptagon", weight: 1/256},
      {name:"Octagon", weight: 1/512},
      {name:"Nonagon", weight: 1/1024},
      {name:"Decagon", weight: 1/2048},
    ];

    // Convert weights to probabilities summing to 1
    // weights are 1/chance, so actual probabilities are weight / sum(weights)
    // But here weight is 1/chance, so to get probability proportional to chance = 1/weight,
    // we invert weight to chance, then normalize
    // Actually, weights are 1/chance, so chance = 1/weight.
    // So to get probability for selection: probability_i = chance_i / totalChanceSum
    // So:
    const chances = shapes.map(s => 1/s.weight);
    const totalChance = chances.reduce((a,b)=>a+b,0);
    const probabilities = chances.map(c => c/totalChance);

    // Weighted random selection helper:
    function weightedRandom(items, probs) {
      let r = Math.random();
      let acc = 0;
      for (let i=0; i<items.length; i++) {
        acc += probs[i];
        if (r <= acc) return items[i];
      }
      return items[items.length-1];
    }

    // Three.js setup - 2D shape shown on a white square with grey edges
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Canvas texture for shape name text
    const textCanvas = document.createElement('canvas');
    textCanvas.width = 256;
    textCanvas.height = 256;
    const ctx = textCanvas.getContext('2d');

    // Function to draw text on canvas
    function drawText(text) {
      ctx.fillStyle = 'white';
      ctx.fillRect(0,0,textCanvas.width,textCanvas.height);
      ctx.fillStyle = 'red';
      ctx.font = 'bold 60px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, textCanvas.width/2, textCanvas.height/2);
      textTexture.needsUpdate = true;
    }

    const textTexture = new THREE.CanvasTexture(textCanvas);

    // Cube white face materials, except front uses text texture
    const faceMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    const textMaterial = new THREE.MeshBasicMaterial({map: textTexture});

    const materials = [
      faceMaterial, faceMaterial, faceMaterial,
      faceMaterial, textMaterial, faceMaterial
    ];

    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const cube = new THREE.Mesh(geometry, materials);

    // Grey edges outline
    const edges = new THREE.EdgesGeometry(geometry);
    const edgeLines = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0x888888}));
    cube.add(edgeLines);

    scene.add(cube);

    function render() {
      renderer.render(scene, camera);
    }
    render();

    // Track counts of shapes rolled
    let shapeCounts = JSON.parse(localStorage.getItem('shapeCounts')) || {};
    for (const s of shapes) {
      if (!(s.name in shapeCounts)) shapeCounts[s.name] = 0;
    }

    // Update counter display
    const counterDiv = document.getElementById('counter');
    function updateCounter() {
      let lines = [];
      for (const s of shapes) {
        lines.push(`${s.name.padEnd(12)}: ${shapeCounts[s.name]}`);
      }
      counterDiv.textContent = lines.join('\n');
    }
    updateCounter();

    // Roll button
    const rollBtn = document.getElementById('rollBtn');
    rollBtn.onclick = () => {
      const rolledShape = weightedRandom(shapes, probabilities);
      drawText(rolledShape.name);
      shapeCounts[rolledShape.name]++;
      localStorage.setItem('shapeCounts', JSON.stringify(shapeCounts));
      updateCounter();
      render();
    };

    // Show last rolled shape if any
    // We'll store last rolled shape name separately
    const lastShape = localStorage.getItem('lastShape');
    if (lastShape && shapeCounts[lastShape] > 0) {
      drawText(lastShape);
      render();
    }

    // Save last rolled shape on rollBtn click
    rollBtn.addEventListener('click', () => {
      const text = ctx.getImageData(0,0,textCanvas.width,textCanvas.height);
      // Actually we have rolledShape inside click handler only, so we save lastShape there:
      // Slight refactor: move save inside rollBtn.onclick
    });

    // We'll refactor rollBtn.onclick to save last rolled shape:
    // Done below with final version.

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    });

    // Refactored rollBtn onclick to save lastShape
    rollBtn.onclick = () => {
      const rolledShape = weightedRandom(shapes, probabilities);
      drawText(rolledShape.name);
      shapeCounts[rolledShape.name]++;
      localStorage.setItem('shapeCounts', JSON.stringify(shapeCounts));
      localStorage.setItem('lastShape', rolledShape.name);
      updateCounter();
      render();
    };
  </script>
</body>
</html>
